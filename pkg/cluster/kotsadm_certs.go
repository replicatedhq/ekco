package cluster

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"strings"
	"time"

	"github.com/pkg/errors"
	k8serrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/duration"
	"k8s.io/client-go/util/cert"
	certutil "k8s.io/client-go/util/cert"
)

func (c *Controller) RotateKurlProxyCert() error {
	ns := c.Config.KurlProxyCertNamespace
	secretName := c.Config.KurlProxyCertSecret

	// 1. Parse current cert from secret
	secret, err := c.Config.Client.CoreV1().Secrets(ns).Get(secretName, metav1.GetOptions{})
	if err != nil {
		if k8serrors.IsNotFound(err) {
			c.Log.Debugf("Kurl proxy cert secret does not exist, skipping renewal")
			return nil
		}
		return errors.Wrapf(err, "get kurl proxy secret")
	}
	certs, err := cert.ParseCertsPEM(secret.Data["tls.crt"])
	if err != nil {
		return errors.Wrapf(err, "parse kurl proxy secret tls.crt")
	}
	if len(certs) == 0 {
		return fmt.Errorf("No certs found in kurl proxy secret tls.crt")
	}
	cert := certs[0]

	// 2. Abort if current cert is not expiring within TTL deadline
	ttl := time.Until(cert.NotAfter)
	if ttl > c.Config.RotateCertsTTL {
		c.Log.Debugf("Kurl proxy cert has %s until expiration, skipping renewal", duration.ShortHumanDuration(ttl))
		return nil
	}

	// 3. Abort if current cert is a custom uploaded cert
	// If generated by kurl installer Subject will be "kotsadm.default.svc.cluster.local" and Issuer
	// will be empty. If already rotated by ekco then Subject will be like
	// "kotsadm.default.svc.cluster.local@1604697213" and Issuer like
	// "kotsadm.default.svc.cluster.local-ca@1604697213"
	if cert.Issuer.CommonName != "" && !strings.HasPrefix(cert.Issuer.CommonName, "kotsadm.default.svc.cluster.local") {
		c.Log.Debugf("Custom cert issuer detected in kurl proxy secret tls.crt, skipping renewal")
		return nil
	}
	if !strings.HasPrefix(cert.Subject.CommonName, "kotsadm.default.svc.cluster.local") {
		c.Log.Debugf("Custom cert subject detected in kurl proxy secret tls.crt, skipping renewal")
		return nil
	}

	// 4. Generate a new self-signed cert
	c.Log.Infof("Kurl proxy cert has %s until expiration, renewing", duration.ShortHumanDuration(ttl))
	certData, keyData, err := certutil.GenerateSelfSignedCertKey("kotsadm.default.svc.cluster.local", cert.IPAddresses, cert.DNSNames)
	if err != nil {
		return errors.Wrapf(err, "generate self-signed cert")
	}

	// 5. Update the secret
	secret.Data["tls.crt"] = certData
	secret.Data["tls.key"] = keyData
	if _, err := c.Config.Client.CoreV1().Secrets(ns).Update(secret); err != nil {
		return errors.Wrapf(err, "update")
	}

	return nil
}

// Copies apiserver-kubelet-client.crt into secret used by kotsadm to collect metrics
func (c *Controller) UpdateKubeletClientCertSecret() error {
	ns := c.Config.KotsadmKubeletCertNamespace
	secretName := c.Config.KotsadmKubeletCertSecret

	secret, err := c.Config.Client.CoreV1().Secrets(ns).Get(secretName, metav1.GetOptions{})
	if err != nil {
		if k8serrors.IsNotFound(err) {
			c.Log.Debugf("Kubelet client secret does not exist, skipping update")
			return nil
		}
		return errors.Wrapf(err, "get kubelet client secret")
	}

	certData, err := ioutil.ReadFile("/etc/kubernetes/pki/apiserver-kubelet-client.crt")
	if err != nil {
		return errors.Wrapf(err, "read /etc/kubernetes/pki/apiserver-kubelet-client.crt")
	}
	keyData, err := ioutil.ReadFile("/etc/kubernetes/pki/apiserver-kubelet-client.key")
	if err != nil {
		return errors.Wrapf(err, "read /etc/kubernetes/pki/apiserver-kubelet-client.key")
	}

	needsUpdate := false
	if !bytes.Equal(secret.Data["client.crt"], certData) {
		needsUpdate = true
		secret.Data["client.crt"] = certData
	}
	if !bytes.Equal(secret.Data["client.key"], keyData) {
		needsUpdate = true
		secret.Data["client.key"] = keyData
	}

	if !needsUpdate {
		c.Log.Debug("Kubelet client cert has not changed, no update needed")
		return nil
	}

	c.Log.Info("Updating kubelet client cert")
	if _, err := c.Config.Client.CoreV1().Secrets(ns).Update(secret); err != nil {
		return errors.Wrapf(err, "update")
	}

	return nil
}
